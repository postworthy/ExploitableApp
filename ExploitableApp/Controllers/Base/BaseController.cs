using ExploitableApp.Data.Managers;
using ExploitableApp.Data.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ExploitableApp.Controllers.Base
{
    /*
     * 
     * It is very common to want to share base functionality across multiple classes and centralizing using good object oriented patterns is the way to go!
     * 
     * But wait! What if we take this farther than we should? If we are not careful we could share more than we want to share...
     * 
     * For example: If we put a common utility style call in a shared method and make it available everywhere then we may give away out users data!
     * 
     */
    public class BaseController : Controller
    {
        protected readonly UserManager<ApplicationUser> _userManager;
        protected readonly CustomUserManager _customUserManager;
        protected readonly ILogger _logger;

        public BaseController(
            UserManager<ApplicationUser> userManager,
            CustomUserManager customUserManager,
            ILogger logger)
        {
            _userManager = userManager;
            _customUserManager = customUserManager;
            _logger = logger;
        }

        [HttpGet]
        [AllowAnonymous] //<--- I copy and pasted this error and now our secrets can be exposed! Oh No!
        public async Task<IActionResult> GetUser(string id, string search = null)
        {
            if (!string.IsNullOrEmpty(search))
            {
                _logger.LogInformation($"GetUser - Searching By {search}");
                var top10 = _userManager.Users
                    .Where(x => x.Email.ToLower().StartsWith(search))
                    .Take(10)
                    .Select(x=>new { id = x.Id, email = x.Email })
                    .Where(x=>x.email.ToLower() != "admin@exploitable.app")
                    .ToList();
                return Json(top10);
            }
            else
            {
                _logger.LogInformation($"GetUser - ID = {id}");
                var user = await _userManager.FindByIdAsync(id);
                if (user == null)
                {
                    throw new ApplicationException($"Unable to load user with ID '{id}'.");
                }
                return Json(user); //<--- Do we really need to return everything about the user? Do we even know what all this contains?
            }
        }

        [HttpGet]
        [AllowAnonymous] //<--- I copy and pasted this error and now our secrets can be exposed! Oh No!
        public async Task<IActionResult> IsAdmin(string id)
        {
            try
            {
                _logger.LogInformation($"IsAdmin - ID = {id}");
                var user = await _userManager.FindByIdAsync(id);
                return Json(new { UserID = id, IsAdmin = await _userManager.IsInRoleAsync(user, "Administrator") });
            }
            catch { return Json(new { UserID = id, IsAdmin = false }); }
        }

        [HttpGet]
        [AllowAnonymous] //<--- I copy and pasted this error and now our secrets can be exposed! Oh No!
        public IActionResult GetUsersPaged(int id, int pageSize = 25) //<--- Notice that this can be enumerated quite easily even though our user IDs are complex, combine this with our GetUser(string id) call and we have all we need 
        {
            _logger.LogInformation($"GetUsersPaged - Page Index = {id} & Page Size = {pageSize}");
            var users = _userManager.Users.Skip(id * pageSize).Take(pageSize).ToList().Select(x => (UserId: x.Id, Name: x.UserName));
            return Json(users);
        }

        [HttpGet]
        [AllowAnonymous] //<--- I copy and pasted this error and now our secrets can be exposed! Oh No!
        public async Task<IActionResult> GetImage(string v) //<-- Now this path is not going to be filtered and will be placed straight into a dangerous method and fed back to the user base64 encoded...so yeah, it is exploitable...
        {
            //The only reason this is done is some obfuscation to make it slightly more challenging
            var imagePath = Encoding.ASCII.GetString(Convert.FromBase64String(v));
            imagePath = imagePath.Replace("\\", "/");
            var env = ((IHostingEnvironment)HttpContext.RequestServices.GetService(typeof(IHostingEnvironment)));
            if (env.ContentRootPath.StartsWith("/"))
                imagePath = imagePath.Replace("C:", "").Replace("c:", "");
            var ext = imagePath.Split('.').Last();
            if (System.IO.File.Exists(imagePath))
            {
                _logger.LogInformation($"GetImage - Path Found = {imagePath}");
                return Content($"data:image/{(ext == "svg" ? "svg+xml" : ext)};base64,{Convert.ToBase64String(await System.IO.File.ReadAllBytesAsync(imagePath))}");
            }

            _logger.LogWarning($"GetImage - Path Not Found = {imagePath}");
            return new NotFoundResult();
        }


        [HttpGet]
        [AllowAnonymous]
        public IEnumerable<string> AccountExists(string email)
        {
            return _customUserManager.GetEmailsLike(email);
        }
    }
}
